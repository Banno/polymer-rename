'use strict';
const PolymerTemplateExpressions = require('./polymer-template-expressions');
const path = require('path');
const Analyzer = require('polymer-analyzer').Analyzer;
const {FSUrlLoader} = require('polymer-analyzer/lib/url-loader/fs-url-loader');
const {InMemoryOverlayUrlLoader} = require('polymer-analyzer/lib/url-loader/overlay-loader');
const {DomModule} = require('polymer-analyzer/lib/polymer/dom-module-scanner');
const {PolymerElement} = require('polymer-analyzer/lib/polymer/polymer-element');

const ignoredWarnings = new Set();
ignoredWarnings.add('unanalyzable-polymer-expression');

/**
 * Main entry point for the phase 1 extraction - analyzes Polymer HTML
 * and JS files, extracts all data binding and HTML code references and
 * returns JS to be provided to Closure-Compiler for type checking and
 * renaming.
 *
 * @param {string} projectRoot path to root to resolve import URLs
 * @param {...(string|Vinyl)} files - either path names or Vinyl files
 * @return {!Promise<!{
 *    output: string,
 *    warnings: !Array<string>
 *  }>} Object with JS code for compilation and an Array of warnings
 */
function parsePolymerElements(projectRoot, ...files) {
  projectRoot = path.resolve(projectRoot);
  const loader = new InMemoryOverlayUrlLoader(new FSUrlLoader(projectRoot));

  const analyzer = new Analyzer({
    urlLoader: loader
  });

  const warnings = [];

  const filePaths = files.map(file => {
    const filePath = file.relative || file.path || path.relative(projectRoot, file);
    const fileContents = file.contents ? file.contents.toString() : undefined;
    if (fileContents) {
      loader.urlContentsMap.set(filePath, fileContents);
    }
    return filePath;
  });

  return analyzer.analyze(filePaths)
      .then(analysis => {
        const data = {
          features: new Set(),
          htmlDocuments: new Map()
        };

        analysis.getFeatures().forEach(feature => {
          if (feature instanceof PolymerElement ||
              feature instanceof DomModule) {
            data.features.add(feature);
          } else if (feature.kinds.has('html-document')) {
            data.htmlDocuments.set(feature.identifiers.values().next().value,
                feature._scannedDocument.document.contents);
          }
        });
        return data;
      })
      .then(data => {
        const features = data.features;
        const renameableElementProps = new Map();
        const domModules = new Set();
        features.forEach(feature => {
          if (feature instanceof PolymerElement && feature.tagName) {
            if (renameableElementProps.has(feature.tagName)) {
              throw new Error(`Duplicate polymer element definition encountered for ${feature.tagName}.`);
            }

            renameableElementProps.set(
                feature.tagName,
                feature);

            feature.warnings.forEach(warning => {
              if (ignoredWarnings.has(warning.code)) {
                return;
              }
              warnings.push(feature.tagName + ' ' + warning.message + ' ' + warning.sourceRange.file + ' line ' +
                  warning.sourceRange.start.line);
            });
          } else if (feature instanceof DomModule) {
            domModules.add(feature);
          }
        });

        const typeNamesByTagName = new Map();
        renameableElementProps.forEach((polymerElement, tagName) => {
          if (polymerElement.className) {
            typeNamesByTagName.set(polymerElement.tagName, polymerElement.className);
          }
        });

        const typeNameLookup = tagName => {
          const typeName = typeNamesByTagName.get(tagName);
          if (typeName) {
            return typeName;
          }

          if (tagName.indexOf('-') > 0) {
            return PolymerTemplateExpressions.defaultTypeNameForTag(tagName);
          }
          return undefined;
        };

        const polymerElements = new Set();
        domModules.forEach(domModule => {
          if (domModule.identifiers.size !== 1) {
            throw new Error('<dom-module> element without id attribute at line ' +
                `${domModule.node.__location.line}  col ${domModule.node.__location.col}`);
          }
          let id = null;
          domModule.identifiers.forEach(identifier => {
            id = identifier;
          });
          if (!renameableElementProps.has(id)) {
            // this can occur for shared style includes.
            return;
          }

          polymerElements.add(
              new PolymerTemplateExpressions(domModule.node, id, data.htmlDocuments.get(domModule.sourceRange.file),
                  renameableElementProps, typeNameLookup));
        });

        let output = [
          '// This file was autogenerated by polymer-rename. Do not edit.',
          ''
        ];
        polymerElements.forEach(elem => {
          elem.warnings.forEach(warning => warnings.push(warning));

          if (elem.subExpressions.length === 0) {
            return;
          }
          output.push(`(/** @this {${elem.typeName}} @suppress {visibility} */ function() {`);
          output.push(outputPolymerExpr(elem, ''));
          output.push(`}).call(/** @type {!${elem.typeName}} */ (document.createElement("${elem.tagName}")));`);
        });

        return {
          output: output.join('\n') + '\n',
          warnings
        };
      }).catch(err => {
        console.error(err);
      });
}

/**
 * Helper function to convert extracted expressions to properly formatted JS.
 * Recursively walk the expression tree and return a JS string.
 *
 * @param {Object} expression starting point
 * @param {string} indent whitespace to use for each indent level
 * @return {string} indented JS
 */
function outputPolymerExpr(expression, indent) {
  const output = [];
  if (!(expression instanceof PolymerTemplateExpressions)) {
    const str = expression.toString(indent);
    if (str.length > 0) {
      output.push(str);
    }
  }
  if (expression.subExpressions) {
    expression.subExpressions.forEach(item => {
      const str = outputPolymerExpr(item, indent + '  ');
      if (str.length > 0) {
        output.push(str);
      }
    });
  }

  if (!(expression instanceof PolymerTemplateExpressions) && expression.subExpressions) {
    const str = expression.toClosingString(indent);
    if (str.length > 0) {
      output.push(str);
    }
  }
  return output.join('\n');
}

module.exports = parsePolymerElements;
