'use strict';
const PolymerTemplateExpressions = require('./polymer-template-expressions');
const path = require('path');
const Analyzer = require('polymer-analyzer').Analyzer;
const FSUrlLoader = require('polymer-analyzer/lib/url-loader/fs-url-loader').FSUrlLoader;
const PackageUrlResolver = require('polymer-analyzer/lib/url-loader/package-url-resolver').PackageUrlResolver;
const {Element, ElementReference} = require('polymer-analyzer/lib/model/element');
const {DomModule} = require('polymer-analyzer/lib/polymer/dom-module-scanner');
const {PolymerElement} = require('polymer-analyzer/lib/polymer/polymer-element');
const {Behavior} = require('polymer-analyzer/lib/polymer/behavior');

/**
 * @param {string} projectRoot
 * @param {...(string|Vinyl)} files - either path names or Vinyl files
 * @returns {Promise<string>}
 */
function parsePolymerElements(projectRoot, ...files) {
  projectRoot = path.resolve(projectRoot);
  const analyzer = new Analyzer({
    urlLoader: new FSUrlLoader(projectRoot),
    urlResolver: new PackageUrlResolver(),
  });

  let analyzePromises = Promise.resolve({
    features: new Set(),
    htmlDocuments: new Map()
  });

  files.forEach(file => {
    const filePath = file.path || path.relative(projectRoot, file);
    const fileContents = file.contents ? file.contents.toString() : undefined;
    analyzePromises = analyzePromises.then(data => {
      return analyzer.analyze(filePath, fileContents).then(document => {
        if (document.kinds.has('html-document')) {
          data.htmlDocuments.set(document.identifiers.values().next().value,
              document._scannedDocument.document.contents);
        }
        // data.htmlDocuments.set(,);
        document.getFeatures().forEach(feature => {
          if (feature instanceof PolymerElement
              || feature instanceof DomModule) {

            data.features.add(feature);
          }
        });
        return data;
      })
    });
  });

  return analyzePromises
      .then(data => {
        const features = data.features;
        const renameableElementProps = new Map();
        const domModules = new Set();
        features.forEach(feature => {
          if (feature instanceof PolymerElement && feature.tagName) {
            if (renameableElementProps.has(feature.tagName)) {
              throw new Error(`Duplicate polymer element definition encountered for ${feature.tagName}.`);
            }

            renameableElementProps.set(
                feature.tagName,
                feature);

          } else if (feature instanceof DomModule) {
            domModules.add(feature);
          }
        });

        const typeNamesByTagName = new Map();
        renameableElementProps.forEach((tagName, polymerElement) => {
          typeNamesByTagName.set(tagName, polymerElement.className);
        });

        const polymerElements = new Set();
        domModules.forEach(domModule => {
          if (domModule.identifiers.size !== 1) {
            throw new Error('<dom-module> element without id attribute at line '
                + `${domModule.node.__location.line}  col ${domModule.node.__location.col}`);
          }
          let id = null;
          domModule.identifiers.forEach(identifier => id = identifier);
          if (!renameableElementProps.has(id)) {
            // this can occur for shared style includes.
            return;
          }

          polymerElements.add(
              new PolymerTemplateExpressions(domModule.node, id, data.htmlDocuments.get(domModule.sourceRange.file),
                  typeNamesByTagName, renameableElementProps, tagName => {
                    const typeName = typeNamesByTagName.get(tagName);
                    if (typeName) {
                      return typeName;
                    }
                    if (tagName.indexOf('-') > 0) {
                      return PolymerTemplateExpressions.defaultTypeNameForTag(tagName);
                    }
                    return undefined;
                  }));
        });

        let output = [
          '// This file was autogenerated by polymer-rename. Do not edit.',
          ''
        ];
        polymerElements.forEach(elem => {
          if (elem.subExpressions.length === 0) {
            return;
          }
          output.push(`(/** @this {${elem.typeName}} @suppress {visibility} */ function() {`);
          output.push(outputPolymerExpr(elem, ''));
          output.push(`}).call(/** @type {!${elem.typeName}} */ (document.createElement("${elem.tagName}")));`);
        });

        return output.join('\n') + '\n';
      });
}

function outputPolymerExpr(expression, indent) {
  const output = [];
  if (!(expression instanceof PolymerTemplateExpressions)) {
    const str = expression.toString(indent);
    if (str.length > 0) {
      output.push(str);
    }
  }
  if (expression.subExpressions) {
    expression.subExpressions.forEach(item => {
      const str =outputPolymerExpr(item, indent + '  ');
      if (str.length > 0) {
        output.push(str);
      }
    });
  }

  if (!(expression instanceof PolymerTemplateExpressions) && expression.subExpressions) {
    const str = expression.toClosingString(indent);
    if (str.length > 0) {
      output.push(str);
    }
  }
  return output.join('\n');
}

module.exports = parsePolymerElements;
